?start: _NL* _value
// TODO: fix optional types to be None in transformer when there aren't any (maybe_placeholders?)
_value : [MAPPING_TYPE] _uon_mapping | [SEQUENCE_TYPE] _uon_seq | schema
_uon_mapping: yaml_mapping | (json_mapping _NL*)
_uon_seq: yaml_seq | (json_seq _NL*)

// yaml structure
yaml_seq: seq_item+
yaml_mapping : pair+
_yaml_collection: [MAPPING_TYPE] yaml_mapping | [SEQUENCE_TYPE] yaml_seq
pair: pair_key ":" _yaml_value
seq_item : "-" _yaml_value
_yaml_collection_nested: _NL [_INDENT _yaml_collection _DEDENT]
yaml_user_type: _custom_type _NL _INDENT yaml_mapping _DEDENT
_yaml_value: _scalar _NL+ | _yaml_collection_nested | yaml_user_type | null _NL+

// json structure
json_mapping : "{" [json_pair ("," json_pair)*] "}"
json_pair: pair_key ":" _json_value
json_seq : "[" [_json_value ("," _json_value)*] "]"
_json_collection: [MAPPING_TYPE] json_mapping | [SEQUENCE_TYPE] json_seq
json_user_type: _custom_type json_mapping
_json_value: _scalar | (_json_collection _NL*) | json_user_type | null


_scalar : coercible_scalar | boolean_scalar
// TODO: fix null, true/false values in transformer 
// TODO: (include null among scalar values and watch out for eventual ambiguities empty against null)
coercible_scalar : (typed_scalar | _scalar_value)
typed_scalar : scalar_type  (typed_scalar | _scalar_value)
_scalar_value : (escaped_string | string | number)

boolean_scalar: [BOOL_TYPE] _boolean

pair_key : (string | escaped_string) [presentation_properties]

presentation_properties : "(" [_presentation_property ("," _presentation_property)*] ")"
_presentation_property : optional | description
description: "description" ":" (string | escaped_string)
optional : "optional" ":" _boolean

// TODO: handle optional parameter attributes
schema: _custom_type ":" "schema" "{" [attributes] "}" _NL*
attributes: attribute ("," attribute)*
attribute: pair_key ":" _validation_properties

// Validation properties
_validation_properties: string_validation 
                      | number_validation 
                      | boolean_validation

// TODO: keep properties optional as string properties below?
// number validation
number_validation: number_validation_type [number_properties]
number_properties: "(" _number_property ("," _number_property)* ")"
_number_property: number_max | number_min
number_max: "max" ":" number
number_min: "min" ":" number
number_validation_type: FLOAT_TYPE -> float_type 
                      | INT_TYPE -> int_type
                      | UINT_TYPE -> uint_type

// string validation
string_validation: STR_TYPE string_properties
string_properties: ["(" _string_property ("," _string_property)* ")"]
_string_property: string_max | string_min
string_max: "max" ":" decimal
string_min: "min" ":" decimal

// boolean validation
boolean_validation: BOOL_TYPE

// User defined types
_custom_type: "!!" WORD

_boolean: (true | false)
true : "true" | "True"
false : "false" | "False"
null: "null"
// TODO: import escaped string perhaps
// Don't need to add number at the start of escaped_string because they will be interpreted 
// as strings anyways since quotes mark the beginning of a string.
escaped_string : "\"" WORD+ "\"" | "'" WORD+ "'"
string :  number WORD+ | WORD+
number : decimal | float_number | signed_number
decimal.2 : DECIMAL
float_number.2: FLOAT_NUMBER
signed_number.2: SIGNED_NUMBER

// TODO: Fix strings that may begin with "!!" if none of the types below matched 
// TODO: (maybe use a punctuation rule to complement the string rule)
// https://www.regextester.com/95226

// Collections types
collection_type : MAPPING_TYPE | SEQUENCE_TYPE
MAPPING_TYPE: "!mapping"
SEQUENCE_TYPE: "!seq"

// Scalar types (Only those eligible for type coercion, so booleans are not included)
scalar_type : STR_TYPE | _number_type
_number_type: FLOAT_128_TYPE | FLOAT_64_TYPE | FLOAT_32_TYPE
               | INT_128_TYPE | INT_64_TYPE | INT_32_TYPE
               | UINT_128_TYPE | UINT_64_TYPE | UINT_32_TYPE
               | FLOAT_TYPE | INT_TYPE | UINT_TYPE

STR_TYPE: "!str"
BOOL_TYPE: "!bool"

FLOAT_TYPE: "!float"
FLOAT_128_TYPE: "!float128"
FLOAT_64_TYPE: "!float64"
FLOAT_32_TYPE: "!float32"

INT_TYPE: "!int"
INT_128_TYPE: "!int128"
INT_64_TYPE: "!int64"
INT_32_TYPE: "!int32"

UINT_TYPE: "!uint"
UINT_128_TYPE: "!uint128"
UINT_64_TYPE: "!uint64"
UINT_32_TYPE: "!uint32"

DECIMAL : /0|[1-9]\d*/i
FLOAT_NUMBER: /((\d+\.\d*|\.\d+)(e[-+]?\d+)?|\d+(e[-+]?\d+))/i

// TODO: folded style strings?
// Word with all possible characters except the following negated set
WORD:  /[^:#,()\[\]{}!?.\n\"\'\s]+/
COMMENT: /#[^\n]*/
%import common.SIGNED_NUMBER
%import common.WS_INLINE
%declare _INDENT _DEDENT
%ignore COMMENT
%ignore WS_INLINE
_NL: /(\r?\n[\t ]*)+/