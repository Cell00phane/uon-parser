from lark import Transformer, v_args
from lark.indenter import Indenter

from uonrevisedtypes.uon_pair_key import UonPairKey, UonPairKeyProperties
from uonrevisedtypes.uon_pair import UonPair
from uonrevisedtypes.scalars.uon_float import Float64
from uonrevisedtypes.scalars.uon_integer import Integer64
from uonrevisedtypes.type_coercion import type_constructors
from uonrevisedtypes.collections.uon_dict import UONDictionary
from uonrevisedtypes.uon_custom_type import UonCustomType

from validation.properties.string.string_min_property import MinStringValidation
from validation.properties.string.string_max_property import MaxStringValidation
from validation.properties.number.number_min_property import MinNumberValidation
from validation.properties.number.number_max_property import MaxNumberValidation
from validation.types.string.string_type_validation import StringTypeValidation
from validation.types.number.int_type_validation import IntegerTypeValidation
from validation.types.number.float_type_validation import FloatTypeValidation
from validation.types.number.uint_type_validation import UintTypeValidation
from validation.validator import Validator
from validation.schema import Schema

# TODO: multiline string as OPEN/CLOSED PAREN TYPES
class TreeIndenter(Indenter):
    NL_type = '_NL'
    OPEN_PAREN_types = ['LPAR', 'LSQB', 'LBRACE']
    CLOSE_PAREN_types = ['RPAR', 'RSQB', 'RBRACE']
    INDENT_type = '_INDENT'
    DEDENT_type = '_DEDENT'
    tab_len = 8

# TODO: use logging
# TODO: consider using UON Dictionary throughout
class UON2RevisedTreeToPython(Transformer):
    """
    A transformer for the parse tree generated by the uon 2 revised grammar.

    Note: Transformer methods receive parse trees (instances of lark.tree.Tree)
    and decide what to do with their content. Parse trees' children consist of 
    leaves (tokens) or other trees. Leaves represent the terminals in our 
    grammar. They are wrapped in Tokens (instances of lark.lexer.Token) where 
    'Token' is a subclass of python string. So you can use usual string methods
    on them like slicing.
    """
    def __init__(self):
        '''
        We save all the schemas we have in a dictionary. Whenever 
        a custom type is encountered it is validated before that dictionary.
        '''
        super().__init__()
        self.schemas = {}

    @v_args(inline=True)
    def name(self, string):
        print("visiting name: ", string)
        (s,) = string
        return s
        
    def escaped_string(self, s):
        print("visiting escaped string: ", s)
        # (s,) = s
        # return s[1:-1].replace('\\"', '"')
        s = ' '.join(s)
        print("joining string: ", s)
        return s

    def string(self, string):
        print("visiting string: ", string)
        s = ' '.join(string)
        print("joining string: ", s)
        return s

    @v_args(inline=True)
    def decimal(self, n):
        print("visiting decimal: ", n)
        return Integer64(n)

    @v_args(inline=True)
    def float_number(self, n):
        print("visiting float: ", n)
        return Float64(n)

    @v_args(inline=True)
    def signed_number(self, n):
        print("visiting float: ", n)
        return Float64(n)

    @v_args(inline=True)
    def number(self, n):
        print("visiting number: ", n)
        return n

    # TODO: Custom exceptions (for example a mapping type expected instead of seq)
    def yaml_mapping(self, mapping):
        print("visiting yaml mapping: ", mapping)
        return dict(mapping)

    def json_mapping(self, mapping):
        print("visiting json mapping: ", mapping)
        return dict(mapping)

    def yaml_seq(self, seq):
        print("visiting yaml seq: ", seq)
        return seq
    
    def json_seq(self, seq):
        print("visiting json seq: ", seq)
        return seq

    def seq_item(self, items):
        print("visiting seq items: ", items)
        return items[0]

    @v_args(inline=True)
    def pair(self, key, value):
        print("visiting pair: ", key, ": ", value)
        return key.keyname, value

    @v_args(inline=True)
    def json_pair(self, key, value):
        print("visiting json pair: ", key, ": ", value)
        return key.keyname, value

    def pair_key(self, key):
        print("visiting pair_key: ", key)
        return UonPairKey(key[0], key[1] if len(key) > 1 else None)
    
    def presentation_properties(self, properties):
        """
        We will be receiving properties as a list of pairs.
        We transform the properties into a dictionary of properties names
        and their values. That way, if a certain property is repeated,
        it will keep only its last value.
        """
        print("visiting key_properties: ", properties, end="\n")
        properties = dict(properties)
        description = properties.get("description")
        optional = properties.get("optional", False)
        return UonPairKeyProperties(description, optional)

    @v_args(inline=True)
    def description(self, value):
        """
        Get the description and return it as a pair
        "description" : <description>
        """
        print("visiting description: ", value)
        return "description", value

    @v_args(inline=True)
    def optional(self, value):
        """
        Get the optional value and return it as a pair
        "optional" : <optional>
        """
        print("visiting optional: ", value)
        return "optional", value

    @v_args(inline=True)
    def scalar(self, value):
        print("visiting scalar: ", value)
        return value
    
    def typed_scalar(self, value):
        '''
        Receive a typed scalar in the form of a list ["!<TYPE>"", <VALUE>]
        We extract <TYPE> from the first element and use it to find the
        corresponding constructor to coerce the type of <VALUE>
        '''
        print("visiting typed_scalar: ", value, " with type: ", value[0])
        return_value = type_constructors[value[0][1:]](value[1].value)
        return return_value
    
    @v_args(inline=True)
    def scalar_type(self, t):
        print("visiting scalar_type: ", t)
        return t

    # ======================== VALIDATION ========================
    @v_args(inline=True)
    def json_user_type(self, custom_type, attributes):
        print("visiting json_user_type {} with attributes {}".format(
            custom_type, attributes
        ))
        custom_object = UonCustomType(custom_type, attributes)
        schema = self.schemas.get(custom_type)
        if schema is not None:
            schema.validateSchema(custom_object)
        return custom_object

    @v_args(inline=True)
    def yaml_user_type(self, custom_type, attributes):
        print("visiting yaml_user_type {} with attributes {}".format(
            custom_type, attributes
        ))
        custom_object = UonCustomType(custom_type, attributes)
        schema = self.schemas.get(custom_type)
        if schema is not None:
            schema.validateSchema(custom_object)
        return custom_object

    @v_args(inline=True)
    def schema(self, custom_type, attributes):
        print("visiting schema: {} with attributes {}"
              .format(custom_type, attributes))
        schema_ = Schema(custom_type, dict(attributes))
        self.schemas[custom_type] = schema_
        return schema_

    def attributes(self, attributes_):
        print("visiting schema attributes: ", attributes_)
        return attributes_

    @v_args(inline=True)
    def attribute(self, attribute_name, validator):
        print("visiting schema attribute: {} with validator {}"
              .format(attribute_name, validator))
        return (attribute_name, validator)

    @v_args(inline=True)
    def attribute_name(self, attribute_name_):
        print("visiting attribute_name: ", attribute_name_)
        return attribute_name_.value
    
    @v_args(inline=True)
    def string_validation(self, str_type, string_validators):
        print("visiting string_validation: ", string_validators)
        return Validator(StringTypeValidation(), string_validators)

    def string_properties(self, properties):
        print("visiting string_properties: ", properties)
        return properties

    @v_args(inline=True)
    def string_min(self, min_):
        """ Here we receive decimals """
        print("visiting string_min: ", min_)
        return MinStringValidation(min_.value)

    @v_args(inline=True)
    def string_max(self, max_):
        print("visiting string_max: ", max_)
        return MaxStringValidation(max_.value)

    @v_args(inline=True)
    def number_validation(self, num_type, number_validators):
        print("visiting number_validation: ", num_type, " ", number_validators)
        return Validator(num_type, number_validators)

    def number_properties(self, properties):
        print("visiting number_properties: ", properties)
        return properties

    @v_args(inline=True)
    def number_min(self, min_):
        print("visiting number_min: ", min_)
        return MinNumberValidation(min_.value)

    @v_args(inline=True)
    def number_max(self, max_):
        print("visiting number_max: ", max_)
        return MaxNumberValidation(max_.value)

    def float_type(self, type_):
        return FloatTypeValidation()
    
    def int_type(self, type_):
        return IntegerTypeValidation()
    
    def uint_type(self, type_):
        return UintTypeValidation()

    # ======================== UTILITY METHODS ========================
    def supply_schemas(self, schemas):
        self.schemas.update(schemas)

    null = lambda self, _: None
    true = lambda self, _: True
    false = lambda self, _: False
